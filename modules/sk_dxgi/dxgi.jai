// MIT License

// Copyright (c) 2022 Hamad Almamari (hamad-r)

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// dxgi 1.6 (SDK v10.0.18362.0) Generated by jaicc.
// - macros ported manually. (only which we care about)

// - types renamed manually (in order):
// - ": UINT64" -> ": u64"
// - "UINT16" -> "u16"
// - ": UINT" -> ": u32" and "*UINT" -> "*u32"
// - ": INT" -> ": s32" and "*INT" -> "*s32"
// - "WCHAR" -> "u16"
// - "BYTE" -> "u8"
// - "FLOAT" -> "float32"
// - enum s32 -> enum u32

#assert(OS == .WINDOWS);

//### from winerror.h (manually)
DXGI_STATUS_OCCLUDED :: 0x087A0001;
DXGI_STATUS_CLIPPED :: 0x087A0002;
DXGI_STATUS_NO_REDIRECTION :: 0x087A0004;
DXGI_STATUS_NO_DESKTOP_ACCESS :: 0x087A0005;
DXGI_STATUS_GRAPHICS_VIDPN_SOURCE_IN_USE :: 0x087A0006;
DXGI_STATUS_MODE_CHANGED :: 0x087A0007;
DXGI_STATUS_MODE_CHANGE_IN_PROGRESS :: 0x087A0008;
DXGI_ERROR_INVALID_CALL :: 0x887A0001;
DXGI_ERROR_NOT_FOUND :: 0x887A0002;
DXGI_ERROR_MORE_DATA :: 0x887A0003;
DXGI_ERROR_UNSUPPORTED :: 0x887A0004;
DXGI_ERROR_DEVICE_REMOVED :: 0x887A0005;
DXGI_ERROR_DEVICE_HUNG :: 0x887A0006;
DXGI_ERROR_DEVICE_RESET :: 0x887A0007;
DXGI_ERROR_WAS_STILL_DRAWING :: 0x887A000A;
DXGI_ERROR_FRAME_STATISTICS_DISJOINT :: 0x887A000B;
DXGI_ERROR_GRAPHICS_VIDPN_SOURCE_IN_USE :: 0x887A000C;
DXGI_ERROR_DRIVER_INTERNAL_ERROR :: 0x887A0020;
DXGI_ERROR_NONEXCLUSIVE :: 0x887A0021;
DXGI_ERROR_NOT_CURRENTLY_AVAILABLE :: 0x887A0022;
DXGI_ERROR_REMOTE_CLIENT_DISCONNECTED :: 0x887A0023;
DXGI_ERROR_REMOTE_OUTOFMEMORY :: 0x887A0024;
DXGI_ERROR_ACCESS_LOST :: 0x887A0026;
DXGI_ERROR_WAIT_TIMEOUT :: 0x887A0027;
DXGI_ERROR_SESSION_DISCONNECTED :: 0x887A0028;
DXGI_ERROR_RESTRICT_TO_OUTPUT_STALE :: 0x887A0029;
DXGI_ERROR_CANNOT_PROTECT_CONTENT :: 0x887A002A;
DXGI_ERROR_ACCESS_DENIED :: 0x887A002B;
DXGI_ERROR_NAME_ALREADY_EXISTS :: 0x887A002C;
DXGI_ERROR_SDK_COMPONENT_MISSING :: 0x887A002D;
DXGI_ERROR_NOT_CURRENT :: 0x887A002E;
DXGI_ERROR_HW_PROTECTION_OUTOFMEMORY :: 0x887A0030;
DXGI_ERROR_DYNAMIC_CODE_POLICY_VIOLATION :: 0x887A0031;
DXGI_ERROR_NON_COMPOSITED_UI :: 0x887A0032;
DXGI_STATUS_UNOCCLUDED :: 0x087A0009;
DXGI_STATUS_DDA_WAS_STILL_DRAWING :: 0x087A000A;
DXGI_ERROR_MODE_CHANGE_IN_PROGRESS :: 0x887A0025;
DXGI_STATUS_PRESENT_REQUIRED :: 0x087A002F;
DXGI_ERROR_CACHE_CORRUPT :: 0x887A0033;
DXGI_ERROR_CACHE_FULL :: 0x887A0034;
DXGI_ERROR_CACHE_HASH_COLLISION :: 0x887A0035;
DXGI_ERROR_ALREADY_EXISTS :: 0x887A0036;
DXGI_DDI_ERR_WASSTILLDRAWING :: 0x887B0001;
DXGI_DDI_ERR_UNSUPPORTED :: 0x887B0002;
DXGI_DDI_ERR_NONEXCLUSIVE :: 0x887B0003;

//### from dxgicommon.h

DXGI_RATIONAL :: struct {
    Numerator: u32;
    Denominator: u32;
}

DXGI_SAMPLE_DESC :: struct {
    Count: u32;
    Quality: u32;
}

using DXGI_COLOR_SPACE_TYPE :: enum u32 {
    DXGI_COLOR_SPACE_RGB_FULL_G22_NONE_P709 :: 0;
    DXGI_COLOR_SPACE_RGB_FULL_G10_NONE_P709 :: 1;
    DXGI_COLOR_SPACE_RGB_STUDIO_G22_NONE_P709 :: 2;
    DXGI_COLOR_SPACE_RGB_STUDIO_G22_NONE_P2020 :: 3;
    DXGI_COLOR_SPACE_RESERVED :: 4;
    DXGI_COLOR_SPACE_YCBCR_FULL_G22_NONE_P709_X601 :: 5;
    DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P601 :: 6;
    DXGI_COLOR_SPACE_YCBCR_FULL_G22_LEFT_P601 :: 7;
    DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P709 :: 8;
    DXGI_COLOR_SPACE_YCBCR_FULL_G22_LEFT_P709 :: 9;
    DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P2020 :: 10;
    DXGI_COLOR_SPACE_YCBCR_FULL_G22_LEFT_P2020 :: 11;
    DXGI_COLOR_SPACE_RGB_FULL_G2084_NONE_P2020 :: 12;
    DXGI_COLOR_SPACE_YCBCR_STUDIO_G2084_LEFT_P2020 :: 13;
    DXGI_COLOR_SPACE_RGB_STUDIO_G2084_NONE_P2020 :: 14;
    DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_TOPLEFT_P2020 :: 15;
    DXGI_COLOR_SPACE_YCBCR_STUDIO_G2084_TOPLEFT_P2020 :: 16;
    DXGI_COLOR_SPACE_RGB_FULL_G22_NONE_P2020 :: 17;
    DXGI_COLOR_SPACE_YCBCR_STUDIO_GHLG_TOPLEFT_P2020 :: 18;
    DXGI_COLOR_SPACE_YCBCR_FULL_GHLG_TOPLEFT_P2020 :: 19;
    DXGI_COLOR_SPACE_RGB_STUDIO_G24_NONE_P709 :: 20;
    DXGI_COLOR_SPACE_RGB_STUDIO_G24_NONE_P2020 :: 21;
    DXGI_COLOR_SPACE_YCBCR_STUDIO_G24_LEFT_P709 :: 22;
    DXGI_COLOR_SPACE_YCBCR_STUDIO_G24_LEFT_P2020 :: 23;
    DXGI_COLOR_SPACE_YCBCR_STUDIO_G24_TOPLEFT_P2020 :: 24;
    // DXGI_COLOR_SPACE_CUSTOM :: -1;
}

//### from dxgiformat.h

using DXGI_FORMAT :: enum u32 {
    DXGI_FORMAT_UNKNOWN :: 0;
    DXGI_FORMAT_R32G32B32A32_TYPELESS :: 1;
    DXGI_FORMAT_R32G32B32A32_FLOAT :: 2;
    DXGI_FORMAT_R32G32B32A32_UINT :: 3;
    DXGI_FORMAT_R32G32B32A32_SINT :: 4;
    DXGI_FORMAT_R32G32B32_TYPELESS :: 5;
    DXGI_FORMAT_R32G32B32_FLOAT :: 6;
    DXGI_FORMAT_R32G32B32_UINT :: 7;
    DXGI_FORMAT_R32G32B32_SINT :: 8;
    DXGI_FORMAT_R16G16B16A16_TYPELESS :: 9;
    DXGI_FORMAT_R16G16B16A16_FLOAT :: 10;
    DXGI_FORMAT_R16G16B16A16_UNORM :: 11;
    DXGI_FORMAT_R16G16B16A16_UINT :: 12;
    DXGI_FORMAT_R16G16B16A16_SNORM :: 13;
    DXGI_FORMAT_R16G16B16A16_SINT :: 14;
    DXGI_FORMAT_R32G32_TYPELESS :: 15;
    DXGI_FORMAT_R32G32_FLOAT :: 16;
    DXGI_FORMAT_R32G32_UINT :: 17;
    DXGI_FORMAT_R32G32_SINT :: 18;
    DXGI_FORMAT_R32G8X24_TYPELESS :: 19;
    DXGI_FORMAT_D32_FLOAT_S8X24_UINT :: 20;
    DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS :: 21;
    DXGI_FORMAT_X32_TYPELESS_G8X24_UINT :: 22;
    DXGI_FORMAT_R10G10B10A2_TYPELESS :: 23;
    DXGI_FORMAT_R10G10B10A2_UNORM :: 24;
    DXGI_FORMAT_R10G10B10A2_UINT :: 25;
    DXGI_FORMAT_R11G11B10_FLOAT :: 26;
    DXGI_FORMAT_R8G8B8A8_TYPELESS :: 27;
    DXGI_FORMAT_R8G8B8A8_UNORM :: 28;
    DXGI_FORMAT_R8G8B8A8_UNORM_SRGB :: 29;
    DXGI_FORMAT_R8G8B8A8_UINT :: 30;
    DXGI_FORMAT_R8G8B8A8_SNORM :: 31;
    DXGI_FORMAT_R8G8B8A8_SINT :: 32;
    DXGI_FORMAT_R16G16_TYPELESS :: 33;
    DXGI_FORMAT_R16G16_FLOAT :: 34;
    DXGI_FORMAT_R16G16_UNORM :: 35;
    DXGI_FORMAT_R16G16_UINT :: 36;
    DXGI_FORMAT_R16G16_SNORM :: 37;
    DXGI_FORMAT_R16G16_SINT :: 38;
    DXGI_FORMAT_R32_TYPELESS :: 39;
    DXGI_FORMAT_D32_FLOAT :: 40;
    DXGI_FORMAT_R32_FLOAT :: 41;
    DXGI_FORMAT_R32_UINT :: 42;
    DXGI_FORMAT_R32_SINT :: 43;
    DXGI_FORMAT_R24G8_TYPELESS :: 44;
    DXGI_FORMAT_D24_UNORM_S8_UINT :: 45;
    DXGI_FORMAT_R24_UNORM_X8_TYPELESS :: 46;
    DXGI_FORMAT_X24_TYPELESS_G8_UINT :: 47;
    DXGI_FORMAT_R8G8_TYPELESS :: 48;
    DXGI_FORMAT_R8G8_UNORM :: 49;
    DXGI_FORMAT_R8G8_UINT :: 50;
    DXGI_FORMAT_R8G8_SNORM :: 51;
    DXGI_FORMAT_R8G8_SINT :: 52;
    DXGI_FORMAT_R16_TYPELESS :: 53;
    DXGI_FORMAT_R16_FLOAT :: 54;
    DXGI_FORMAT_D16_UNORM :: 55;
    DXGI_FORMAT_R16_UNORM :: 56;
    DXGI_FORMAT_R16_UINT :: 57;
    DXGI_FORMAT_R16_SNORM :: 58;
    DXGI_FORMAT_R16_SINT :: 59;
    DXGI_FORMAT_R8_TYPELESS :: 60;
    DXGI_FORMAT_R8_UNORM :: 61;
    DXGI_FORMAT_R8_UINT :: 62;
    DXGI_FORMAT_R8_SNORM :: 63;
    DXGI_FORMAT_R8_SINT :: 64;
    DXGI_FORMAT_A8_UNORM :: 65;
    DXGI_FORMAT_R1_UNORM :: 66;
    DXGI_FORMAT_R9G9B9E5_SHAREDEXP :: 67;
    DXGI_FORMAT_R8G8_B8G8_UNORM :: 68;
    DXGI_FORMAT_G8R8_G8B8_UNORM :: 69;
    DXGI_FORMAT_BC1_TYPELESS :: 70;
    DXGI_FORMAT_BC1_UNORM :: 71;
    DXGI_FORMAT_BC1_UNORM_SRGB :: 72;
    DXGI_FORMAT_BC2_TYPELESS :: 73;
    DXGI_FORMAT_BC2_UNORM :: 74;
    DXGI_FORMAT_BC2_UNORM_SRGB :: 75;
    DXGI_FORMAT_BC3_TYPELESS :: 76;
    DXGI_FORMAT_BC3_UNORM :: 77;
    DXGI_FORMAT_BC3_UNORM_SRGB :: 78;
    DXGI_FORMAT_BC4_TYPELESS :: 79;
    DXGI_FORMAT_BC4_UNORM :: 80;
    DXGI_FORMAT_BC4_SNORM :: 81;
    DXGI_FORMAT_BC5_TYPELESS :: 82;
    DXGI_FORMAT_BC5_UNORM :: 83;
    DXGI_FORMAT_BC5_SNORM :: 84;
    DXGI_FORMAT_B5G6R5_UNORM :: 85;
    DXGI_FORMAT_B5G5R5A1_UNORM :: 86;
    DXGI_FORMAT_B8G8R8A8_UNORM :: 87;
    DXGI_FORMAT_B8G8R8X8_UNORM :: 88;
    DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM :: 89;
    DXGI_FORMAT_B8G8R8A8_TYPELESS :: 90;
    DXGI_FORMAT_B8G8R8A8_UNORM_SRGB :: 91;
    DXGI_FORMAT_B8G8R8X8_TYPELESS :: 92;
    DXGI_FORMAT_B8G8R8X8_UNORM_SRGB :: 93;
    DXGI_FORMAT_BC6H_TYPELESS :: 94;
    DXGI_FORMAT_BC6H_UF16 :: 95;
    DXGI_FORMAT_BC6H_SF16 :: 96;
    DXGI_FORMAT_BC7_TYPELESS :: 97;
    DXGI_FORMAT_BC7_UNORM :: 98;
    DXGI_FORMAT_BC7_UNORM_SRGB :: 99;
    DXGI_FORMAT_AYUV :: 100;
    DXGI_FORMAT_Y410 :: 101;
    DXGI_FORMAT_Y416 :: 102;
    DXGI_FORMAT_NV12 :: 103;
    DXGI_FORMAT_P010 :: 104;
    DXGI_FORMAT_P016 :: 105;
    DXGI_FORMAT_420_OPAQUE :: 106;
    DXGI_FORMAT_YUY2 :: 107;
    DXGI_FORMAT_Y210 :: 108;
    DXGI_FORMAT_Y216 :: 109;
    DXGI_FORMAT_NV11 :: 110;
    DXGI_FORMAT_AI44 :: 111;
    DXGI_FORMAT_IA44 :: 112;
    DXGI_FORMAT_P8 :: 113;
    DXGI_FORMAT_A8P8 :: 114;
    DXGI_FORMAT_B4G4R4A4_UNORM :: 115;
    DXGI_FORMAT_P208 :: 130;
    DXGI_FORMAT_V208 :: 131;
    DXGI_FORMAT_V408 :: 132;
    // DXGI_FORMAT_FORCE_UINT :: -1;
}

//### from dxgitype.h

DXGI_RGB :: struct {
    Red: float32;
    Green: float32;
    Blue: float32;
}

D3DCOLORVALUE :: struct {
    r: float32;
    g: float32;
    b: float32;
    a: float32;
}

DXGI_RGBA :: D3DCOLORVALUE;

DXGI_GAMMA_CONTROL :: struct {
    Scale: DXGI_RGB;
    Offset: DXGI_RGB;
    GammaCurve: [1025] DXGI_RGB;
}

DXGI_GAMMA_CONTROL_CAPABILITIES :: struct {
    ScaleAndOffsetSupported: BOOL;
    MaxConvertedValue: float32;
    MinConvertedValue: float32;
    NumGammaControlPoints: u32;
    ControlPointPositions: [1025] float32;
}

using DXGI_MODE_SCANLINE_ORDER :: enum u32 {
    DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED :: 0;
    DXGI_MODE_SCANLINE_ORDER_PROGRESSIVE :: 1;
    DXGI_MODE_SCANLINE_ORDER_UPPER_FIELD_FIRST :: 2;
    DXGI_MODE_SCANLINE_ORDER_LOWER_FIELD_FIRST :: 3;
}

using DXGI_MODE_SCALING :: enum u32 {
    DXGI_MODE_SCALING_UNSPECIFIED :: 0;
    DXGI_MODE_SCALING_CENTERED :: 1;
    DXGI_MODE_SCALING_STRETCHED :: 2;
}

using DXGI_MODE_ROTATION :: enum u32 {
    DXGI_MODE_ROTATION_UNSPECIFIED :: 0;
    DXGI_MODE_ROTATION_IDENTITY :: 1;
    DXGI_MODE_ROTATION_ROTATE90 :: 2;
    DXGI_MODE_ROTATION_ROTATE180 :: 3;
    DXGI_MODE_ROTATION_ROTATE270 :: 4;
}

DXGI_MODE_DESC :: struct {
    Width: u32;
    Height: u32;
    RefreshRate: DXGI_RATIONAL;
    Format: DXGI_FORMAT;
    ScanlineOrdering: DXGI_MODE_SCANLINE_ORDER;
    Scaling: DXGI_MODE_SCALING;
}

DXGI_JPEG_DC_HUFFMAN_TABLE :: struct {
    CodeCounts: [12] u8;
    CodeValues: [12] u8;
}

DXGI_JPEG_AC_HUFFMAN_TABLE :: struct {
    CodeCounts: [16] u8;
    CodeValues: [162] u8;
}

DXGI_JPEG_QUANTIZATION_TABLE :: struct {
    Elements: [64] u8;
}

//### from dxgi.h

// manually
DXGI_CPU_ACCESS_NONE       :: 0;
DXGI_CPU_ACCESS_DYNAMIC    :: 1;
DXGI_CPU_ACCESS_READ_WRITE :: 2;
DXGI_CPU_ACCESS_SCRATCH    :: 3;
DXGI_CPU_ACCESS_FIELD      :: 15;

DXGI_USAGE_SHADER_INPUT         :: 0x00000010;
DXGI_USAGE_RENDER_TARGET_OUTPUT :: 0x00000020;
DXGI_USAGE_BACK_BUFFER          :: 0x00000040;
DXGI_USAGE_SHARED               :: 0x00000080;
DXGI_USAGE_READ_ONLY            :: 0x00000100;
DXGI_USAGE_DISCARD_ON_PRESENT   :: 0x00000200;
DXGI_USAGE_UNORDERED_ACCESS     :: 0x00000400;

DXGI_MAX_SWAP_CHAIN_BUFFERS         :: 16;
DXGI_PRESENT_TEST                   :: 0x00000001;
DXGI_PRESENT_DO_NOT_SEQUENCE        :: 0x00000002;
DXGI_PRESENT_RESTART                :: 0x00000004;
DXGI_PRESENT_DO_NOT_WAIT            :: 0x00000008;
DXGI_PRESENT_STEREO_PREFER_RIGHT    :: 0x00000010;
DXGI_PRESENT_STEREO_TEMPORARY_MONO  :: 0x00000020;
DXGI_PRESENT_RESTRICT_TO_OUTPUT     :: 0x00000040;
DXGI_PRESENT_USE_DURATION           :: 0x00000100;


DXGI_MWA_NO_WINDOW_CHANGES :: (1 << 0);
DXGI_MWA_NO_ALT_ENTER :: (1 << 1);
DXGI_MWA_NO_PRINT_SCREEN :: (1 << 2);
DXGI_MWA_VALID :: (0x7);

// auto

DXGI_USAGE :: u32;

DXGI_FRAME_STATISTICS :: struct {
    PresentCount: u32;
    PresentRefreshCount: u32;
    SyncRefreshCount: u32;
    SyncQPCTime: LARGE_INTEGER;
    SyncGPUTime: LARGE_INTEGER;
}

DXGI_MAPPED_RECT :: struct {
    Pitch: s32;
    pBits: *u8;
}

LUID :: struct {
    LowPart : u32;
    HighPart : s32;
}

DXGI_ADAPTER_DESC :: struct {
    Description: [128] u16;
    VendorId: u32;
    DeviceId: u32;
    SubSysId: u32;
    Revision: u32;
    DedicatedVideoMemory: SIZE_T;
    DedicatedSystemMemory: SIZE_T;
    SharedSystemMemory: SIZE_T;
    AdapterLuid: LUID;
}

DXGI_OUTPUT_DESC :: struct {
    DeviceName: [32] u16;
    DesktopCoordinates: RECT;
    AttachedToDesktop: BOOL;
    Rotation: DXGI_MODE_ROTATION;
    Monitor: HMONITOR;
}

DXGI_SHARED_RESOURCE :: struct {
    Handle: HANDLE;
}

using DXGI_RESIDENCY :: enum u32 {
    DXGI_RESIDENCY_FULLY_RESIDENT :: 1;
    DXGI_RESIDENCY_RESIDENT_IN_SHARED_MEMORY :: 2;
    DXGI_RESIDENCY_EVICTED_TO_DISK :: 3;
}

DXGI_SURFACE_DESC :: struct {
    Width: u32;
    Height: u32;
    Format: DXGI_FORMAT;
    SampleDesc: DXGI_SAMPLE_DESC;
}

using DXGI_SWAP_EFFECT :: enum u32 {
    DXGI_SWAP_EFFECT_DISCARD :: 0;
    DXGI_SWAP_EFFECT_SEQUENTIAL :: 1;
    DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL :: 3;
    DXGI_SWAP_EFFECT_FLIP_DISCARD :: 4;
}

using DXGI_SWAP_CHAIN_FLAG :: enum u32 {
    DXGI_SWAP_CHAIN_FLAG_NONPREROTATED :: 1;
    DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH :: 2;
    DXGI_SWAP_CHAIN_FLAG_GDI_COMPATIBLE :: 4;
    DXGI_SWAP_CHAIN_FLAG_RESTRICTED_CONTENT :: 8;
    DXGI_SWAP_CHAIN_FLAG_RESTRICT_SHARED_RESOURCE_DRIVER :: 16;
    DXGI_SWAP_CHAIN_FLAG_DISPLAY_ONLY :: 32;
    DXGI_SWAP_CHAIN_FLAG_FRAME_LATENCY_WAITABLE_OBJECT :: 64;
    DXGI_SWAP_CHAIN_FLAG_FOREGROUND_LAYER :: 128;
    DXGI_SWAP_CHAIN_FLAG_FULLSCREEN_VIDEO :: 256;
    DXGI_SWAP_CHAIN_FLAG_YUV_VIDEO :: 512;
    DXGI_SWAP_CHAIN_FLAG_HW_PROTECTED :: 1024;
    DXGI_SWAP_CHAIN_FLAG_ALLOW_TEARING :: 2048;
    DXGI_SWAP_CHAIN_FLAG_RESTRICTED_TO_ALL_HOLOGRAPHIC_DISPLAYS :: 4096;
}

DXGI_SWAP_CHAIN_DESC :: struct {
    BufferDesc: DXGI_MODE_DESC;
    SampleDesc: DXGI_SAMPLE_DESC;
    BufferUsage: DXGI_USAGE;
    BufferCount: u32;
    OutputWindow: HWND;
    Windowed: BOOL;
    SwapEffect: DXGI_SWAP_EFFECT;
    Flags: u32;
}


IDXGIObject :: struct {
    using vtable : *IDXGIObject_VTable;
    uuid :: "aec22fb8-76f3-4639-9be0-28eb43a67a2e";
    iid  :: IID_IDXGIObject;
}

IDXGIObject_VTable :: struct {
    using unknown : IUnknown_VTable;
    SetPrivateData : (this: *IDXGIObject, Name: *GUID, DataSize: u32, pData: *void) -> HRESULT #cpp_method #foreign;
    SetPrivateDataInterface : (this: *IDXGIObject, Name: *GUID, pUnknown: *IUnknown) -> HRESULT #cpp_method #foreign;
    GetPrivateData : (this: *IDXGIObject, Name: *GUID, pDataSize: *u32, pData: *void) -> HRESULT #cpp_method #foreign;
    GetParent : (this: *IDXGIObject, riid: *IID, ppParent: **void) -> HRESULT #cpp_method #foreign;
}

IDXGIDeviceSubObject :: struct {
    using vtable : *IDXGIDeviceSubObject_VTable;
    uuid :: "3d3e0379-f9de-4d58-bb6c-18d62992f1a6";
    iid  :: IID_IDXGIDeviceSubObject;
}

IDXGIDeviceSubObject_VTable :: struct {
    using object : IDXGIObject_VTable;
    GetDevice : (this: *IDXGIDeviceSubObject, riid: *IID, ppDevice: **void) -> HRESULT #cpp_method #foreign;
}

IDXGIResource :: struct {
    using vtable : *IDXGIResource_VTable;
    uuid :: "035f3ab4-482e-4e50-b41f-8a7f8bd8960b";
    iid  :: IID_IDXGIResource;
}

IDXGIResource_VTable :: struct {
    using device_sub_object : IDXGIDeviceSubObject_VTable;
    GetSharedHandle : (this: *IDXGIResource, pSharedHandle: *HANDLE) -> HRESULT #cpp_method #foreign;
    GetUsage : (this: *IDXGIResource, pUsage: *DXGI_USAGE) -> HRESULT #cpp_method #foreign;
    SetEvictionPriority : (this: *IDXGIResource, EvictionPriority: u32) -> HRESULT #cpp_method #foreign;
    GetEvictionPriority : (this: *IDXGIResource, pEvictionPriority: *u32) -> HRESULT #cpp_method #foreign;
}

IDXGIKeyedMutex :: struct {
    using vtable : *IDXGIKeyedMutex_VTable;
    uuid :: "9d8e1289-d7b3-465f-8126-250e349af85d";
    iid  :: IID_IDXGIKeyedMutex;
}

IDXGIKeyedMutex_VTable :: struct {
    using device_sub_object : IDXGIDeviceSubObject_VTable;
    AcquireSync : (this: *IDXGIKeyedMutex, Key: u64, dwMilliseconds: u32) -> HRESULT #cpp_method #foreign;
    ReleaseSync : (this: *IDXGIKeyedMutex, Key: u64) -> HRESULT #cpp_method #foreign;
}

IDXGISurface :: struct {
    using vtable : *IDXGISurface_VTable;
    uuid :: "cafcb56c-6ac3-4889-bf47-9e23bbd260ec";
    iid  :: IID_IDXGISurface;
}

IDXGISurface_VTable :: struct {
    using device_sub_object : IDXGIDeviceSubObject_VTable;
    GetDesc : (this: *IDXGISurface, pDesc: *DXGI_SURFACE_DESC) -> HRESULT #cpp_method #foreign;
    Map : (this: *IDXGISurface, pLockedRect: *DXGI_MAPPED_RECT, MapFlags : u32) -> HRESULT #cpp_method #foreign;
    Unmap : (this: *IDXGISurface) -> HRESULT #cpp_method #foreign;
}

IDXGISurface1 :: struct {
    using vtable : *IDXGISurface1_VTable;
    uuid :: "4AE63092-6327-4c1b-80AE-BFE12EA32B86";
    iid  :: IID_IDXGISurface1;
}

IDXGISurface1_VTable :: struct {
    using surface : IDXGISurface_VTable;
    GetDC : (this: *IDXGISurface1, Discard: BOOL, phdc: *HDC) -> HRESULT #cpp_method #foreign;
    ReleaseDC : (this: *IDXGISurface1, pDirtyRect: *RECT) -> HRESULT #cpp_method #foreign;
}

IDXGIAdapter :: struct {
    using vtable : *IDXGIAdapter_VTable;
    uuid :: "2411e7e1-12ac-4ccf-bd14-9798e8534dc0";
    iid  :: IID_IDXGIAdapter;
}

IDXGIAdapter_VTable :: struct {
    using object : IDXGIObject_VTable;
    EnumOutputs : (this: *IDXGIAdapter, Output : u32, ppOutput: **IDXGIOutput) -> HRESULT #cpp_method #foreign;
    GetDesc : (this: *IDXGIAdapter, pDesc: *DXGI_ADAPTER_DESC) -> HRESULT #cpp_method #foreign;
    CheckInterfaceSupport : (this: *IDXGIAdapter, InterfaceName: REFGUID, pUMDVersion: *LARGE_INTEGER) -> HRESULT #cpp_method #foreign;
}

IDXGIOutput :: struct {
    using vtable : *IDXGIOutput_VTable;
    uuid :: "ae02eedb-c735-4690-8d52-5a8dc20213aa";
    iid  :: IID_IDXGIOutput;
}

IDXGIOutput_VTable :: struct {
    using object : IDXGIObject_VTable;
    GetDesc : (this: *IDXGIOutput, pDesc: *DXGI_OUTPUT_DESC) -> HRESULT #cpp_method #foreign;
    GetDisplayModeList : (this: *IDXGIOutput, EnumFormat: DXGI_FORMAT, Flags : u32, pNumModes : *u32, pDesc: *DXGI_MODE_DESC) -> HRESULT #cpp_method #foreign;
    FindClosestMatchingMode : (this: *IDXGIOutput, pModeToMatch: *DXGI_MODE_DESC, pClosestMatch: *DXGI_MODE_DESC, pConcernedDevice: *IUnknown) -> HRESULT #cpp_method #foreign;
    WaitForVBlank : (this: *IDXGIOutput) -> HRESULT #cpp_method #foreign;
    TakeOwnership : (this: *IDXGIOutput, pDevice: *IUnknown, Exclusive: BOOL) -> HRESULT #cpp_method #foreign;
    ReleaseOwnership : (this: *IDXGIOutput) #cpp_method #foreign;
    GetGammaControlCapabilities : (this: *IDXGIOutput, pGammaCaps: *DXGI_GAMMA_CONTROL_CAPABILITIES) -> HRESULT #cpp_method #foreign;
    SetGammaControl : (this: *IDXGIOutput, pArray: *DXGI_GAMMA_CONTROL) -> HRESULT #cpp_method #foreign;
    GetGammaControl : (this: *IDXGIOutput, pArray: *DXGI_GAMMA_CONTROL) -> HRESULT #cpp_method #foreign;
    SetDisplaySurface : (this: *IDXGIOutput, pScanoutSurface: *IDXGISurface) -> HRESULT #cpp_method #foreign;
    GetDisplaySurfaceData : (this: *IDXGIOutput, pDestination: *IDXGISurface) -> HRESULT #cpp_method #foreign;
    GetFrameStatistics : (this: *IDXGIOutput, pStats: *DXGI_FRAME_STATISTICS) -> HRESULT #cpp_method #foreign;
}

IDXGISwapChain :: struct {
    using vtable : *IDXGISwapChain_VTable;
    uuid :: "310d36a0-d2e7-4c0a-aa04-6a9d23b8886a";
    iid  :: IID_IDXGISwapChain;
}

IDXGISwapChain_VTable :: struct {
    using device_sub_object : IDXGIDeviceSubObject_VTable;
    Present : (this: *IDXGISwapChain, SyncInterval : u32, Flags : u32) -> HRESULT #cpp_method #foreign;
    GetBuffer : (this: *IDXGISwapChain, Buffer : u32, riid: REFIID, ppSurface: **void) -> HRESULT #cpp_method #foreign;
    SetFullscreenState : (this: *IDXGISwapChain, Fullscreen: BOOL, pTarget: *IDXGIOutput) -> HRESULT #cpp_method #foreign;
    GetFullscreenState : (this: *IDXGISwapChain, pFullscreen: *BOOL, ppTarget: **IDXGIOutput) -> HRESULT #cpp_method #foreign;
    GetDesc : (this: *IDXGISwapChain, pDesc: *DXGI_SWAP_CHAIN_DESC) -> HRESULT #cpp_method #foreign;
    ResizeBuffers : (this: *IDXGISwapChain, BufferCount : u32, Width : u32, Height : u32, NewFormat: DXGI_FORMAT, SwapChainFlags : u32) -> HRESULT #cpp_method #foreign;
    ResizeTarget : (this: *IDXGISwapChain, pNewTargetParameters: *DXGI_MODE_DESC) -> HRESULT #cpp_method #foreign;
    GetContainingOutput : (this: *IDXGISwapChain, ppOutput: **IDXGIOutput) -> HRESULT #cpp_method #foreign;
    GetFrameStatistics : (this: *IDXGISwapChain, pStats: *DXGI_FRAME_STATISTICS) -> HRESULT #cpp_method #foreign;
    GetLastPresentCount : (this: *IDXGISwapChain, pLastPresentCount : *u32) -> HRESULT #cpp_method #foreign;
}

IDXGIFactory :: struct {
    using vtable : *IDXGIFactory_VTable;
    uuid :: "7b7166ec-21c7-44ae-b21a-c9ae321ae369";
    iid  :: IID_IDXGIFactory;
}

IDXGIFactory_VTable :: struct {
    using object : IDXGIObject_VTable;
    EnumAdapters : (this: *IDXGIFactory, Adapter : u32, ppAdapter: **IDXGIAdapter) -> HRESULT #cpp_method #foreign;
    MakeWindowAssociation : (this: *IDXGIFactory, WindowHandle: HWND, Flags : u32) -> HRESULT #cpp_method #foreign;
    GetWindowAssociation : (this: *IDXGIFactory, pWindowHandle: *HWND) -> HRESULT #cpp_method #foreign;
    CreateSwapChain : (this: *IDXGIFactory, pDevice: *IUnknown, pDesc: *DXGI_SWAP_CHAIN_DESC, ppSwapChain: **IDXGISwapChain) -> HRESULT #cpp_method #foreign;
    CreateSoftwareAdapter : (this: *IDXGIFactory, Module: HMODULE, ppAdapter: **IDXGIAdapter) -> HRESULT #cpp_method #foreign;
}

CreateDXGIFactory :: (riid: *IID, ppFactory: **void) -> HRESULT #cpp_method #foreign dxgi;
CreateDXGIFactory1 :: (riid: *IID, ppFactory: **void) -> HRESULT #cpp_method #foreign dxgi;

IDXGIDevice :: struct {
    using vtable : *IDXGIDevice_VTable;
    uuid :: "54ec77fa-1377-44e6-8c32-88fd5f44c84c";
    iid  :: IID_IDXGIDevice;
}

IDXGIDevice_VTable :: struct {
    using object : IDXGIObject_VTable;
    GetAdapter : (this: *IDXGIDevice, pAdapter: **IDXGIAdapter) -> HRESULT #cpp_method #foreign;
    CreateSurface : (this: *IDXGIDevice, pDesc: *DXGI_SURFACE_DESC, NumSurfaces : u32, Usage: DXGI_USAGE, pSharedResource: *DXGI_SHARED_RESOURCE, ppSurface: **IDXGISurface) -> HRESULT #cpp_method #foreign;
    QueryResourceResidency : (this: *IDXGIDevice, ppResources: **IUnknown, pResidencyStatus : *DXGI_RESIDENCY, NumResources : u32) -> HRESULT #cpp_method #foreign;
    SetGPUThreadPriority : (this: *IDXGIDevice, Priority: s32) -> HRESULT #cpp_method #foreign;
    GetGPUThreadPriority : (this: *IDXGIDevice, pPriority: *s32) -> HRESULT #cpp_method #foreign;
}

using DXGI_ADAPTER_FLAG :: enum u32 {
    DXGI_ADAPTER_FLAG_NONE :: 0;
    DXGI_ADAPTER_FLAG_REMOTE :: 1;
    DXGI_ADAPTER_FLAG_SOFTWARE :: 2;
    //DXGI_ADAPTER_FLAG_FORCE_DWORD :: -1;
}

DXGI_ADAPTER_DESC1 :: struct {
    Description: [128] u16;
    VendorId: u32;
    DeviceId: u32;
    SubSysId: u32;
    Revision: u32;
    DedicatedVideoMemory: SIZE_T;
    DedicatedSystemMemory: SIZE_T;
    SharedSystemMemory: SIZE_T;
    AdapterLuid: LUID;
    Flags: u32;
}

DXGI_DISPLAY_COLOR_SPACE :: struct {
    PrimaryCoordinates: [8] [2] float32;
    WhitePoints: [16] [2] float32;
}

IDXGIFactory1 :: struct {
    using vtable : *IDXGIFactory1_VTable;
    uuid :: "770aae78-f26f-4dba-a829-253c83d1b387";
    iid  :: IID_IDXGIFactory1; 
}

IDXGIFactory1_VTable :: struct {
    using factory : IDXGIFactory_VTable;
    EnumAdapters1 : (this: *IDXGIFactory1, Adapter: u32, ppAdapter: **IDXGIAdapter1) -> HRESULT #cpp_method #foreign;
    IsCurrent : (this: *IDXGIFactory1) -> BOOL #cpp_method #foreign;
}

IDXGIAdapter1 :: struct {
    using vtable : *IDXGIAdapter1_VTable;
    uuid :: "29038f61-3839-4626-91fd-086879011a05";
    iid  :: IID_IDXGIAdapter1;
}

IDXGIAdapter1_VTable :: struct {
    using adapter : IDXGIAdapter_VTable;
    GetDesc1 : (this: *IDXGIAdapter1, pDesc: *DXGI_ADAPTER_DESC1) -> HRESULT #cpp_method #foreign;
}

IDXGIDevice1 :: struct {
    using vtable : *IDXGIDevice1_VTable;
    uuid :: "77db970f-6276-48ba-ba28-070143b4392c";
    iid  :: IID_IDXGIDevice1;
}

IDXGIDevice1_VTable :: struct {
    using device : IDXGIDevice_VTable;
    SetMaximumFrameLatency : (this: *IDXGIDevice1, MaxLatency : u32) -> HRESULT #cpp_method #foreign;
    GetMaximumFrameLatency : (this: *IDXGIDevice1, pMaxLatency : *u32) -> HRESULT #cpp_method #foreign;
}

IID_IDXGIObject         :: GUID.{0xaec22fb8,0x76f3,0x4639, u8.[0x9b,0xe0,0x28,0xeb,0x43,0xa6,0x7a,0x2e] };
IID_IDXGIDeviceSubObject:: GUID.{0x3d3e0379,0xf9de,0x4d58, u8.[0xbb,0x6c,0x18,0xd6,0x29,0x92,0xf1,0xa6] };
IID_IDXGIResource       :: GUID.{0x035f3ab4,0x482e,0x4e50, u8.[0xb4,0x1f,0x8a,0x7f,0x8b,0xd8,0x96,0x0b] };
IID_IDXGIKeyedMutex     :: GUID.{0x9d8e1289,0xd7b3,0x465f, u8.[0x81,0x26,0x25,0x0e,0x34,0x9a,0xf8,0x5d] };
IID_IDXGISurface        :: GUID.{0xcafcb56c,0x6ac3,0x4889, u8.[0xbf,0x47,0x9e,0x23,0xbb,0xd2,0x60,0xec] };
IID_IDXGISurface1       :: GUID.{0x4AE63092,0x6327,0x4c1b, u8.[0x80,0xAE,0xBF,0xE1,0x2E,0xA3,0x2B,0x86] };
IID_IDXGIAdapter        :: GUID.{0x2411e7e1,0x12ac,0x4ccf, u8.[0xbd,0x14,0x97,0x98,0xe8,0x53,0x4d,0xc0] };
IID_IDXGIOutput         :: GUID.{0xae02eedb,0xc735,0x4690, u8.[0x8d,0x52,0x5a,0x8d,0xc2,0x02,0x13,0xaa] };
IID_IDXGISwapChain      :: GUID.{0x310d36a0,0xd2e7,0x4c0a, u8.[0xaa,0x04,0x6a,0x9d,0x23,0xb8,0x88,0x6a] };
IID_IDXGIFactory        :: GUID.{0x7b7166ec,0x21c7,0x44ae, u8.[0xb2,0x1a,0xc9,0xae,0x32,0x1a,0xe3,0x69] };
IID_IDXGIDevice         :: GUID.{0x54ec77fa,0x1377,0x44e6, u8.[0x8c,0x32,0x88,0xfd,0x5f,0x44,0xc8,0x4c] };
IID_IDXGIFactory1       :: GUID.{0x770aae78,0xf26f,0x4dba, u8.[0xa8,0x29,0x25,0x3c,0x83,0xd1,0xb3,0x87] };
IID_IDXGIAdapter1       :: GUID.{0x29038f61,0x3839,0x4626, u8.[0x91,0xfd,0x08,0x68,0x79,0x01,0x1a,0x05] };
IID_IDXGIDevice1        :: GUID.{0x77db970f,0x6276,0x48ba, u8.[0xba,0x28,0x07,0x01,0x43,0xb4,0x39,0x2c] };

//### from dxgi1_2.h

IDXGIDisplayControl :: struct {
    using vtable : *IDXGIDisplayControl_VTable;
    uuid :: "ea9dbf1a-c88e-4486-854a-98aa0138f30c";
    iid  :: IID_IDXGIDisplayControl;
}

IDXGIDisplayControl_VTable :: struct {
    using unknown : IUnknown_VTable;
    IsStereoEnabled : (this: *IDXGIDisplayControl) -> BOOL #cpp_method #foreign;
    SetStereoEnabled : (this: *IDXGIDisplayControl, enabled: BOOL) -> void #cpp_method #foreign;
}

DXGI_OUTDUPL_MOVE_RECT :: struct {
    SourcePoint: POINT;
    DestinationRect: RECT;
}

DXGI_OUTDUPL_DESC :: struct {
    ModeDesc: DXGI_MODE_DESC;
    Rotation: DXGI_MODE_ROTATION;
    DesktopImageInSystemMemory: BOOL;
}

DXGI_OUTDUPL_POINTER_POSITION :: struct {
    Position: POINT;
    Visible: BOOL;
}

using DXGI_OUTDUPL_POINTER_SHAPE_TYPE :: enum u32 {
    DXGI_OUTDUPL_POINTER_SHAPE_TYPE_MONOCHROME :: 1;
    DXGI_OUTDUPL_POINTER_SHAPE_TYPE_COLOR :: 2;
    DXGI_OUTDUPL_POINTER_SHAPE_TYPE_MASKED_COLOR :: 4;
}

DXGI_OUTDUPL_POINTER_SHAPE_INFO :: struct {
    Type: u32;
    Width: u32;
    Height: u32;
    Pitch: u32;
    HotSpot: POINT;
}

DXGI_OUTDUPL_FRAME_INFO :: struct {
    LastPresentTime: LARGE_INTEGER;
    LastMouseUpdateTime: LARGE_INTEGER;
    AccumulatedFrames: u32;
    RectsCoalesced: BOOL;
    ProtectedContentMaskedOut: BOOL;
    PointerPosition: DXGI_OUTDUPL_POINTER_POSITION;
    TotalMetadataBufferSize: u32;
    PointerShapeBufferSize: u32;
}


IDXGIOutputDuplication :: struct {
    using vtable : *IDXGIOutputDuplication_VTable;
    uuid :: "191cfac3-a341-470d-b26e-a864f428319c";
    iid  :: IID_IDXGIOutputDuplication;
}

IDXGIOutputDuplication_VTable :: struct {
    using object : IDXGIObject_VTable;
    GetDesc : (this: *IDXGIOutputDuplication, pDesc: *DXGI_OUTDUPL_DESC) -> void #cpp_method #foreign;
    AcquireNextFrame : (this: *IDXGIOutputDuplication, TimeoutInMilliseconds: u32, pFrameInfo: *DXGI_OUTDUPL_FRAME_INFO, ppDesktopResource: **IDXGIResource) -> HRESULT #cpp_method #foreign;
    GetFrameDirtyRects : (this: *IDXGIOutputDuplication, DirtyRectsBufferSize: u32, pDirtyRectsBuffer: *RECT, pDirtyRectsBufferSizeRequired: *u32) -> HRESULT #cpp_method #foreign;
    GetFrameMoveRects : (this: *IDXGIOutputDuplication, MoveRectsBufferSize: u32, pMoveRectBuffer: *DXGI_OUTDUPL_MOVE_RECT, pMoveRectsBufferSizeRequired: *u32) -> HRESULT #cpp_method #foreign;
    GetFramePointerShape : (this: *IDXGIOutputDuplication, PointerShapeBufferSize: u32, pPointerShapeBuffer: *void, pPointerShapeBufferSizeRequired: *u32, pPointerShapeInfo: *DXGI_OUTDUPL_POINTER_SHAPE_INFO) -> HRESULT #cpp_method #foreign;
    MapDesktopSurface : (this: *IDXGIOutputDuplication, pLockedRect: *DXGI_MAPPED_RECT) -> HRESULT #cpp_method #foreign;
    UnMapDesktopSurface : (this: *IDXGIOutputDuplication) -> HRESULT #cpp_method #foreign;
    ReleaseFrame : (this: *IDXGIOutputDuplication) -> HRESULT #cpp_method #foreign;
}

using DXGI_ALPHA_MODE :: enum u32 {
    DXGI_ALPHA_MODE_UNSPECIFIED :: 0;
    DXGI_ALPHA_MODE_PREMULTIPLIED :: 1;
    DXGI_ALPHA_MODE_STRAIGHT :: 2;
    DXGI_ALPHA_MODE_IGNORE :: 3;
    //DXGI_ALPHA_MODE_FORCE_DWORD :: -1;
}

IDXGISurface2 :: struct {
    using vtable : *IDXGISurface2_VTable;
    uuid :: "aba496dd-b617-4cb8-a866-bc44d7eb1fa2";
    iid  :: IID_IDXGISurface2;
}

IDXGISurface2_VTable :: struct {
    using surface1 : IDXGISurface1_VTable;
    GetResource : (this: *IDXGISurface2, riid: *IID, ppParentResource: **void, pSubresourceIndex: *u32) -> HRESULT #cpp_method #foreign;
}

IDXGIResource1 :: struct {
    using vtable : *IDXGIResource1_VTable;
    uuid :: "30961379-4609-4a41-998e-54fe567ee0c1";
    iid  :: IID_IDXGIResource1;
}

IDXGIResource1_VTable :: struct {
    using resource : IDXGIResource_VTable;
    CreateSubresourceSurface : (this: *IDXGIResource1, index: u32, ppSurface: **IDXGISurface2) -> HRESULT #cpp_method #foreign;
    CreateSharedHandle : (this: *IDXGIResource1, pAttributes: *SECURITY_ATTRIBUTES, dwAccess: DWORD, lpName: LPCWSTR, pHandle: *HANDLE) -> HRESULT #cpp_method #foreign;
}

using DXGI_OFFER_RESOURCE_PRIORITY :: enum u32 {
    DXGI_OFFER_RESOURCE_PRIORITY_LOW :: 1;
    DXGI_OFFER_RESOURCE_PRIORITY_NORMAL :: 2;
    DXGI_OFFER_RESOURCE_PRIORITY_HIGH :: 3;
}

IDXGIDevice2 :: struct {
    using vtable : *IDXGIDevice2_VTable;
    uuid :: "05008617-fbfd-4051-a790-144884b4f6a9";
    iid  :: IID_IDXGIDevice2;
}

IDXGIDevice2_VTable :: struct {
    using device1 : IDXGIDevice1_VTable;
    OfferResources : (this: *IDXGIDevice2, NumResources: u32, ppResources: **IDXGIResource, Priority: DXGI_OFFER_RESOURCE_PRIORITY) -> HRESULT #cpp_method #foreign;
    ReclaimResources : (this: *IDXGIDevice2, NumResources: u32, ppResources: **IDXGIResource, pDiscarded: *BOOL) -> HRESULT #cpp_method #foreign;
    EnqueueSetEvent : (this: *IDXGIDevice2, hEvent: HANDLE) -> HRESULT #cpp_method #foreign;
}

DXGI_MODE_DESC1 :: struct {
    Width: u32;
    Height: u32;
    RefreshRate: DXGI_RATIONAL;
    Format: DXGI_FORMAT;
    ScanlineOrdering: DXGI_MODE_SCANLINE_ORDER;
    Scaling: DXGI_MODE_SCALING;
    Stereo: BOOL;
}

using DXGI_SCALING :: enum u32 {
    DXGI_SCALING_STRETCH :: 0;
    DXGI_SCALING_NONE :: 1;
    DXGI_SCALING_ASPECT_RATIO_STRETCH :: 2;
}

DXGI_SWAP_CHAIN_DESC1 :: struct {
    Width: u32;
    Height: u32;
    Format: DXGI_FORMAT;
    Stereo: BOOL;
    SampleDesc: DXGI_SAMPLE_DESC;
    BufferUsage: DXGI_USAGE;
    BufferCount: u32;
    Scaling: DXGI_SCALING;
    SwapEffect: DXGI_SWAP_EFFECT;
    AlphaMode: DXGI_ALPHA_MODE;
    Flags: u32;
}

DXGI_SWAP_CHAIN_FULLSCREEN_DESC :: struct {
    RefreshRate: DXGI_RATIONAL;
    ScanlineOrdering: DXGI_MODE_SCANLINE_ORDER;
    Scaling: DXGI_MODE_SCALING;
    Windowed: BOOL;
}

DXGI_PRESENT_PARAMETERS :: struct {
    DirtyRectsCount: u32;
    pDirtyRects: *RECT;
    pScrollRect: *RECT;
    pScrollOffset: *POINT;
}

IDXGISwapChain1 :: struct {
    using vtable : *IDXGISwapChain1_VTable;
    uuid :: "790a45f7-0d42-4876-983a-0a55cfe6f4aa";
    iid  :: IID_IDXGISwapChain1;
}

IDXGISwapChain1_VTable :: struct {
    using swap_chain : IDXGISwapChain_VTable;
    GetDesc1 : (this: *IDXGISwapChain1, pDesc: *DXGI_SWAP_CHAIN_DESC1) -> HRESULT #cpp_method #foreign;
    GetFullscreenDesc : (this: *IDXGISwapChain1, pDesc: *DXGI_SWAP_CHAIN_FULLSCREEN_DESC) -> HRESULT #cpp_method #foreign;
    GetHwnd : (this: *IDXGISwapChain1, pHwnd: *HWND) -> HRESULT #cpp_method #foreign;
    GetCoreWindow : (this: *IDXGISwapChain1, refiid: *IID, ppUnk: **void) -> HRESULT #cpp_method #foreign;
    Present1 : (this: *IDXGISwapChain1, SyncInterval: u32, PresentFlags: u32, pPresentParameters: *DXGI_PRESENT_PARAMETERS) -> HRESULT #cpp_method #foreign;
    IsTemporaryMonoSupported : (this: *IDXGISwapChain1) -> BOOL #cpp_method #foreign;
    GetRestrictToOutput : (this: *IDXGISwapChain1, ppRestrictToOutput: **IDXGIOutput) -> HRESULT #cpp_method #foreign;
    SetBackgroundColor : (this: *IDXGISwapChain1, pColor: *DXGI_RGBA) -> HRESULT #cpp_method #foreign;
    GetBackgroundColor : (this: *IDXGISwapChain1, pColor: *DXGI_RGBA) -> HRESULT #cpp_method #foreign;
    SetRotation : (this: *IDXGISwapChain1, Rotation: DXGI_MODE_ROTATION) -> HRESULT #cpp_method #foreign;
    GetRotation : (this: *IDXGISwapChain1, pRotation: *DXGI_MODE_ROTATION) -> HRESULT #cpp_method #foreign;
}

IDXGIFactory2 :: struct {
    using vtable : *IDXGIFactory2_VTable;
    uuid :: "50c83a1c-e072-4c48-87b0-3630fa36a6d0";
    iid  :: IID_IDXGIFactory2;
}

IDXGIFactory2_VTable :: struct {
    using factory1 : IDXGIFactory1_VTable;
    IsWindowedStereoEnabled : (this: *IDXGIFactory2) -> BOOL #cpp_method #foreign;
    CreateSwapChainForHwnd : (this: *IDXGIFactory2, pDevice: *IUnknown, hWnd: HWND, pDesc: *DXGI_SWAP_CHAIN_DESC1, pFullscreenDesc: *DXGI_SWAP_CHAIN_FULLSCREEN_DESC, pRestrictToOutput: *IDXGIOutput, ppSwapChain: **IDXGISwapChain1) -> HRESULT #cpp_method #foreign;
    CreateSwapChainForCoreWindow : (this: *IDXGIFactory2, pDevice: *IUnknown, pWindow: *IUnknown, pDesc: *DXGI_SWAP_CHAIN_DESC1, pRestrictToOutput: *IDXGIOutput, ppSwapChain: **IDXGISwapChain1) -> HRESULT #cpp_method #foreign;
    GetSharedResourceAdapterLuid : (this: *IDXGIFactory2, hResource: HANDLE, pLuid: *LUID) -> HRESULT #cpp_method #foreign;
    RegisterStereoStatusWindow : (this: *IDXGIFactory2, WindowHandle: HWND, wMsg: u32, pdwCookie: *DWORD) -> HRESULT #cpp_method #foreign;
    RegisterStereoStatusEvent : (this: *IDXGIFactory2, hEvent: HANDLE, pdwCookie: *DWORD) -> HRESULT #cpp_method #foreign;
    UnregisterStereoStatus : (this: *IDXGIFactory2, dwCookie: DWORD) -> void #cpp_method #foreign;
    RegisterOcclusionStatusWindow : (this: *IDXGIFactory2, WindowHandle: HWND, wMsg: u32, pdwCookie: *DWORD) -> HRESULT #cpp_method #foreign;
    RegisterOcclusionStatusEvent : (this: *IDXGIFactory2, hEvent: HANDLE, pdwCookie: *DWORD) -> HRESULT #cpp_method #foreign;
    UnregisterOcclusionStatus : (this: *IDXGIFactory2, dwCookie: DWORD) -> void #cpp_method #foreign;
    CreateSwapChainForComposition : (this: *IDXGIFactory2, pDevice: *IUnknown, pDesc: *DXGI_SWAP_CHAIN_DESC1, pRestrictToOutput: *IDXGIOutput, ppSwapChain: **IDXGISwapChain1) -> HRESULT #cpp_method #foreign;
}

using DXGI_GRAPHICS_PREEMPTION_GRANULARITY :: enum u32 {
    DXGI_GRAPHICS_PREEMPTION_DMA_BUFFER_BOUNDARY :: 0;
    DXGI_GRAPHICS_PREEMPTION_PRIMITIVE_BOUNDARY :: 1;
    DXGI_GRAPHICS_PREEMPTION_TRIANGLE_BOUNDARY :: 2;
    DXGI_GRAPHICS_PREEMPTION_PIXEL_BOUNDARY :: 3;
    DXGI_GRAPHICS_PREEMPTION_INSTRUCTION_BOUNDARY :: 4;
}

using DXGI_COMPUTE_PREEMPTION_GRANULARITY :: enum u32 {
    DXGI_COMPUTE_PREEMPTION_DMA_BUFFER_BOUNDARY :: 0;
    DXGI_COMPUTE_PREEMPTION_DISPATCH_BOUNDARY :: 1;
    DXGI_COMPUTE_PREEMPTION_THREAD_GROUP_BOUNDARY :: 2;
    DXGI_COMPUTE_PREEMPTION_THREAD_BOUNDARY :: 3;
    DXGI_COMPUTE_PREEMPTION_INSTRUCTION_BOUNDARY :: 4;
}

DXGI_ADAPTER_DESC2 :: struct {
    Description: [128] u16;
    VendorId: u32;
    DeviceId: u32;
    SubSysId: u32;
    Revision: u32;
    DedicatedVideoMemory: SIZE_T;
    DedicatedSystemMemory: SIZE_T;
    SharedSystemMemory: SIZE_T;
    AdapterLuid: LUID;
    Flags: u32;
    GraphicsPreemptionGranularity: DXGI_GRAPHICS_PREEMPTION_GRANULARITY;
    ComputePreemptionGranularity: DXGI_COMPUTE_PREEMPTION_GRANULARITY;
}

IDXGIAdapter2 :: struct {
    using vtable : *IDXGIAdapter2_VTable;
    uuid :: "0AA1AE0A-FA0E-4B84-8644-E05FF8E5ACB5";
    iid  :: IID_IDXGIAdapter2;
}

IDXGIAdapter2_VTable :: struct {
    using adapter1 : IDXGIAdapter1_VTable;
    GetDesc2 : (this: *IDXGIAdapter2, pDesc: *DXGI_ADAPTER_DESC2) -> HRESULT #cpp_method #foreign;
}

IDXGIOutput1 :: struct {
    using vtable : *IDXGIOutput1_VTable;
    uuid :: "00cddea8-939b-4b83-a340-a685226666cc";
    iid  :: IID_IDXGIOutput1;
}

IDXGIOutput1_VTable :: struct {
    using output : IDXGIOutput_VTable;
    GetDisplayModeList1 : (this: *IDXGIOutput1, EnumFormat: DXGI_FORMAT, Flags: u32, pNumModes: *u32, pDesc: *DXGI_MODE_DESC1) -> HRESULT #cpp_method #foreign;
    FindClosestMatchingMode1 : (this: *IDXGIOutput1, pModeToMatch: *DXGI_MODE_DESC1, pClosestMatch: *DXGI_MODE_DESC1, pConcernedDevice: *IUnknown) -> HRESULT #cpp_method #foreign;
    GetDisplaySurfaceData1 : (this: *IDXGIOutput1, pDestination: *IDXGIResource) -> HRESULT #cpp_method #foreign;
    DuplicateOutput : (this: *IDXGIOutput1, pDevice: *IUnknown, ppOutputDuplication: **IDXGIOutputDuplication) -> HRESULT #cpp_method #foreign;
}

IID_IDXGIDisplayControl     :: GUID.{0xea9dbf1a,0xc88e,0x4486, u8.[0x85,0x4a,0x98,0xaa,0x01,0x38,0xf3,0x0c] };
IID_IDXGIOutputDuplication  :: GUID.{0x191cfac3,0xa341,0x470d, u8.[0xb2,0x6e,0xa8,0x64,0xf4,0x28,0x31,0x9c] };
IID_IDXGISurface2           :: GUID.{0xaba496dd,0xb617,0x4cb8, u8.[0xa8,0x66,0xbc,0x44,0xd7,0xeb,0x1f,0xa2] };
IID_IDXGIResource1          :: GUID.{0x30961379,0x4609,0x4a41, u8.[0x99,0x8e,0x54,0xfe,0x56,0x7e,0xe0,0xc1] };
IID_IDXGIDevice2            :: GUID.{0x05008617,0xfbfd,0x4051, u8.[0xa7,0x90,0x14,0x48,0x84,0xb4,0xf6,0xa9] };
IID_IDXGISwapChain1         :: GUID.{0x790a45f7,0x0d42,0x4876, u8.[0x98,0x3a,0x0a,0x55,0xcf,0xe6,0xf4,0xaa] };
IID_IDXGIFactory2           :: GUID.{0x50c83a1c,0xe072,0x4c48, u8.[0x87,0xb0,0x36,0x30,0xfa,0x36,0xa6,0xd0] };
IID_IDXGIAdapter2           :: GUID.{0x0AA1AE0A,0xFA0E,0x4B84, u8.[0x86,0x44,0xE0,0x5F,0xF8,0xE5,0xAC,0xB5] };
IID_IDXGIOutput1            :: GUID.{0x00cddea8,0x939b,0x4b83, u8.[0xa3,0x40,0xa6,0x85,0x22,0x66,0x66,0xcc] };

CreateDXGIFactory2 :: (Flags: u32, riid: *IID, ppFactory: **void) -> HRESULT #foreign dxgi;
DXGIGetDebugInterface1 :: (Flags: u32, riid: *IID, pDebug: **void) -> HRESULT #foreign dxgi;

//### from dxgi1_3.h

DXGI_CREATE_FACTORY_DEBUG :: 0x1;

IDXGIDevice3 :: struct {
    using vtable : *IDXGIDevice3_VTable;
    uuid :: "6007896c-3244-4afd-bf18-a6d3beda5023";
    iid  :: IID_IDXGIDevice3;
}

IDXGIDevice3_VTable :: struct {
    using device2 : IDXGIDevice2_VTable;
    Trim : (this: *IDXGIDevice3) -> void #cpp_method #foreign;
}

DXGI_MATRIX_3X2_F :: struct {
    _11: float32;
    _12: float32;
    _21: float32;
    _22: float32;
    _31: float32;
    _32: float32;
}

IDXGISwapChain2 :: struct {
    using vtable : *IDXGISwapChain2_VTable;
    uuid :: "a8be2ac4-199f-4946-b331-79599fb98de7";
    iid  :: IID_IDXGISwapChain2;
}

IDXGISwapChain2_VTable :: struct {
    using swap_chain1 : IDXGISwapChain1_VTable;
    SetSourceSize : (this: *IDXGISwapChain2, Width: u32, Height: u32) -> HRESULT #cpp_method #foreign;
    GetSourceSize : (this: *IDXGISwapChain2, pWidth: *u32, pHeight: *u32) -> HRESULT #cpp_method #foreign;
    SetMaximumFrameLatency : (this: *IDXGISwapChain2, MaxLatency: u32) -> HRESULT #cpp_method #foreign;
    GetMaximumFrameLatency : (this: *IDXGISwapChain2, pMaxLatency: *u32) -> HRESULT #cpp_method #foreign;
    GetFrameLatencyWaitableObject : (this: *IDXGISwapChain2) -> HANDLE #cpp_method #foreign;
    SetMatrixTransform : (this: *IDXGISwapChain2, pMatrix: *DXGI_MATRIX_3X2_F) -> HRESULT #cpp_method #foreign;
    GetMatrixTransform : (this: *IDXGISwapChain2, pMatrix: *DXGI_MATRIX_3X2_F) -> HRESULT #cpp_method #foreign;
}

IDXGIOutput2 :: struct {
    using vtable : *IDXGIOutput2_VTable;
    uuid :: "595e39d1-2724-4663-99b1-da969de28364";
    iid  :: IID_IDXGIOutput2;
}

IDXGIOutput2_VTable :: struct {
    using output1 : IDXGIOutput1_VTable;
    SupportsOverlays : (this: *IDXGIOutput2) -> BOOL #cpp_method #foreign;
}

IDXGIFactory3 :: struct {
    using vtable : *IDXGIFactory3_VTable;
    uuid :: "25483823-cd46-4c7d-86ca-47aa95b837bd";
    iid  :: IID_IDXGIFactory3;
}

IDXGIFactory3_VTable :: struct {
    using factory2 : IDXGIFactory2_VTable;
    GetCreationFlags : (this: *IDXGIFactory3) -> u32 #cpp_method #foreign;
}

DXGI_DECODE_SWAP_CHAIN_DESC :: struct {
    Flags: u32;
}

using DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAGS :: enum u32 {
    DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAG_NOMINAL_RANGE :: 1;
    DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAG_BT709 :: 2;
    DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAG_xvYCC :: 4;
}

IDXGIDecodeSwapChain :: struct {
    using vtable : *IDXGIDecodeSwapChain_VTable;
    uuid :: "2633066b-4514-4c7a-8fd8-12ea98059d18";
    iid  :: IID_IDXGIDecodeSwapChain;
}

IDXGIDecodeSwapChain_VTable :: struct {
    using unknown : IUnknown_VTable;
    PresentBuffer : (this: *IDXGIDecodeSwapChain, BufferToPresent: u32, SyncInterval: u32, Flags: u32) -> HRESULT #cpp_method #foreign;
    SetSourceRect : (this: *IDXGIDecodeSwapChain, pRect: *RECT) -> HRESULT #cpp_method #foreign;
    SetTargetRect : (this: *IDXGIDecodeSwapChain, pRect: *RECT) -> HRESULT #cpp_method #foreign;
    SetDestSize : (this: *IDXGIDecodeSwapChain, Width: u32, Height: u32) -> HRESULT #cpp_method #foreign;
    GetSourceRect : (this: *IDXGIDecodeSwapChain, pRect: *RECT) -> HRESULT #cpp_method #foreign;
    GetTargetRect : (this: *IDXGIDecodeSwapChain, pRect: *RECT) -> HRESULT #cpp_method #foreign;
    GetDestSize : (this: *IDXGIDecodeSwapChain, pWidth: *u32, pHeight: *u32) -> HRESULT #cpp_method #foreign;
    SetColorSpace : (this: *IDXGIDecodeSwapChain, ColorSpace: DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAGS) -> HRESULT #cpp_method #foreign;
    GetColorSpace : (this: *IDXGIDecodeSwapChain) -> DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAGS #cpp_method #foreign;
}

IDXGIFactoryMedia :: struct {
    using vtable : *IDXGIFactoryMedia_VTable;
    uuid :: "41e7d1f2-a591-4f7b-a2e5-fa9c843e1c12";
    iid  :: IID_IDXGIFactoryMedia;
}

IDXGIFactoryMedia_VTable :: struct {
    using unknown : IUnknown_VTable;
    CreateSwapChainForCompositionSurfaceHandle : (this: *IDXGIFactoryMedia, pDevice: *IUnknown, hSurface: HANDLE, pDesc: *DXGI_SWAP_CHAIN_DESC1, pRestrictToOutput: *IDXGIOutput, ppSwapChain: **IDXGISwapChain1) -> HRESULT #cpp_method #foreign;
    CreateDecodeSwapChainForCompositionSurfaceHandle : (this: *IDXGIFactoryMedia, pDevice: *IUnknown, hSurface: HANDLE, pDesc: *DXGI_DECODE_SWAP_CHAIN_DESC, pYuvDecodeBuffers: *IDXGIResource, pRestrictToOutput: *IDXGIOutput, ppSwapChain: **IDXGIDecodeSwapChain) -> HRESULT #cpp_method #foreign;
}

using DXGI_FRAME_PRESENTATION_MODE :: enum u32 {
    DXGI_FRAME_PRESENTATION_MODE_COMPOSED :: 0;
    DXGI_FRAME_PRESENTATION_MODE_OVERLAY :: 1;
    DXGI_FRAME_PRESENTATION_MODE_NONE :: 2;
    DXGI_FRAME_PRESENTATION_MODE_COMPOSITION_FAILURE :: 3;
}

DXGI_FRAME_STATISTICS_MEDIA :: struct {
    PresentCount: u32;
    PresentRefreshCount: u32;
    SyncRefreshCount: u32;
    SyncQPCTime: LARGE_INTEGER;
    SyncGPUTime: LARGE_INTEGER;
    CompositionMode: DXGI_FRAME_PRESENTATION_MODE;
    ApprovedPresentDuration: u32;
}

IDXGISwapChainMedia :: struct {
    using vtable : *IDXGISwapChainMedia_VTable;
    uuid :: "dd95b90b-f05f-4f6a-bd65-25bfb264bd84";
    iid  :: IID_IDXGISwapChainMedia;
}

IDXGISwapChainMedia_VTable :: struct {
    using unknown : IUnknown_VTable;
    GetFrameStatisticsMedia : (this: *IDXGISwapChainMedia, pStats: *DXGI_FRAME_STATISTICS_MEDIA) -> HRESULT #cpp_method #foreign;
    SetPresentDuration : (this: *IDXGISwapChainMedia, Duration: u32) -> HRESULT #cpp_method #foreign;
    CheckPresentDurationSupport : (this: *IDXGISwapChainMedia, DesiredPresentDuration: u32, pClosestSmallerPresentDuration: *u32, pClosestLargerPresentDuration: *u32) -> HRESULT #cpp_method #foreign;
}

using DXGI_OVERLAY_SUPPORT_FLAG :: enum u32 {
    DXGI_OVERLAY_SUPPORT_FLAG_DIRECT :: 1;
    DXGI_OVERLAY_SUPPORT_FLAG_SCALING :: 2;
}

IDXGIOutput3 :: struct {
    using vtable : *IDXGIOutput3_VTable;
    uuid :: "8a6bb301-7e7e-41F4-a8e0-5b32f7f99b18";
    iid  :: IID_IDXGIOutput3;
}

IDXGIOutput3_VTable :: struct {
    using output2 : IDXGIOutput2_VTable;
    CheckOverlaySupport : (this: *IDXGIOutput3, EnumFormat: DXGI_FORMAT, pConcernedDevice: *IUnknown, pFlags: *u32) -> HRESULT #cpp_method #foreign;
}

IID_IDXGIDevice3        :: GUID.{0x6007896c,0x3244,0x4afd, u8.[0xbf,0x18,0xa6,0xd3,0xbe,0xda,0x50,0x23] };
IID_IDXGISwapChain2     :: GUID.{0xa8be2ac4,0x199f,0x4946, u8.[0xb3,0x31,0x79,0x59,0x9f,0xb9,0x8d,0xe7] };
IID_IDXGIOutput2        :: GUID.{0x595e39d1,0x2724,0x4663, u8.[0x99,0xb1,0xda,0x96,0x9d,0xe2,0x83,0x64] };
IID_IDXGIFactory3       :: GUID.{0x25483823,0xcd46,0x4c7d, u8.[0x86,0xca,0x47,0xaa,0x95,0xb8,0x37,0xbd] };
IID_IDXGIDecodeSwapChain:: GUID.{0x2633066b,0x4514,0x4c7a, u8.[0x8f,0xd8,0x12,0xea,0x98,0x05,0x9d,0x18] };
IID_IDXGIFactoryMedia   :: GUID.{0x41e7d1f2,0xa591,0x4f7b, u8.[0xa2,0xe5,0xfa,0x9c,0x84,0x3e,0x1c,0x12] };
IID_IDXGISwapChainMedia :: GUID.{0xdd95b90b,0xf05f,0x4f6a, u8.[0xbd,0x65,0x25,0xbf,0xb2,0x64,0xbd,0x84] };
IID_IDXGIOutput3        :: GUID.{0x8a6bb301,0x7e7e,0x41F4, u8.[0xa8,0xe0,0x5b,0x32,0xf7,0xf9,0x9b,0x18] };


using DXGI_SWAP_CHAIN_COLOR_SPACE_SUPPORT_FLAG :: enum u32 {
    DXGI_SWAP_CHAIN_COLOR_SPACE_SUPPORT_FLAG_PRESENT :: 1;
    DXGI_SWAP_CHAIN_COLOR_SPACE_SUPPORT_FLAG_OVERLAY_PRESENT :: 2;
}


//### from dxgi1_4.h

IDXGISwapChain3 :: struct {
    using vtable : *IDXGISwapChain3_VTable;
    uuid :: "94d99bdb-f1f8-4ab0-b236-7da0170edab1";
    iid  :: IID_IDXGISwapChain3;
}

IDXGISwapChain3_VTable :: struct {
    using swap_chain2 : IDXGISwapChain2_VTable;
    GetCurrentBackBufferIndex : (this: *IDXGISwapChain3) -> u32 #cpp_method #foreign;
    CheckColorSpaceSupport : (this: *IDXGISwapChain3, ColorSpace: DXGI_COLOR_SPACE_TYPE, pColorSpaceSupport: *u32) -> HRESULT #cpp_method #foreign;
    SetColorSpace1 : (this: *IDXGISwapChain3, ColorSpace: DXGI_COLOR_SPACE_TYPE) -> HRESULT #cpp_method #foreign;
    ResizeBuffers1 : (this: *IDXGISwapChain3, BufferCount: u32, Width: u32, Height: u32, Format: DXGI_FORMAT, SwapChainFlags: u32, pCreationNodeMask: *u32, ppPresentQueue: **IUnknown) -> HRESULT #cpp_method #foreign;
}

using DXGI_OVERLAY_COLOR_SPACE_SUPPORT_FLAG :: enum u32 {
    DXGI_OVERLAY_COLOR_SPACE_SUPPORT_FLAG_PRESENT :: 1;
}

IDXGIOutput4 :: struct {
    using vtable : *IDXGIOutput4_VTable;
    uuid :: "dc7dca35-2196-414d-9F53-617884032a60";
    iid  :: IID_IDXGIOutput4;
}

IDXGIOutput4_VTable :: struct {
    using output3 : IDXGIOutput3_VTable;
    CheckOverlayColorSpaceSupport : (this: *IDXGIOutput4, Format: DXGI_FORMAT, ColorSpace: DXGI_COLOR_SPACE_TYPE, pConcernedDevice: *IUnknown, pFlags: *u32) -> HRESULT #cpp_method #foreign;
}

IDXGIFactory4 :: struct {
    using vtable : *IDXGIFactory4_VTable;
    uuid :: "1bc6ea02-ef36-464f-bf0c-21ca39e5168a";
    iid  :: IID_IDXGIFactory4;
}

IDXGIFactory4_VTable :: struct {
    using factory3 : IDXGIFactory3_VTable;
    EnumAdapterByLuid : (this: *IDXGIFactory4, AdapterLuid: LUID, riid: *IID, ppvAdapter: **void) -> HRESULT #cpp_method #foreign;
    EnumWarpAdapter : (this: *IDXGIFactory4, riid: *IID, ppvAdapter: **void) -> HRESULT #cpp_method #foreign;
}

using DXGI_MEMORY_SEGMENT_GROUP :: enum u32 {
    DXGI_MEMORY_SEGMENT_GROUP_LOCAL :: 0;
    DXGI_MEMORY_SEGMENT_GROUP_NON_LOCAL :: 1;
}

DXGI_QUERY_VIDEO_MEMORY_INFO :: struct {
    Budget: u64;
    CurrentUsage: u64;
    AvailableForReservation: u64;
    CurrentReservation: u64;
}

IDXGIAdapter3 :: struct {
    using vtable : *IDXGIAdapter3_VTable;
    uuid :: "645967A4-1392-4310-A798-8053CE3E93FD";
    iid  :: IID_IDXGIAdapter3;
}

IDXGIAdapter3_VTable :: struct {
    using adapter2 : IDXGIAdapter2_VTable;
    RegisterHardwareContentProtectionTeardownStatusEvent : (this: *IDXGIAdapter3, hEvent: HANDLE, pdwCookie: *DWORD) -> HRESULT #cpp_method #foreign;
    UnregisterHardwareContentProtectionTeardownStatus : (this: *IDXGIAdapter3, dwCookie: DWORD) -> void #cpp_method #foreign;
    QueryVideoMemoryInfo : (this: *IDXGIAdapter3, NodeIndex: u32, MemorySegmentGroup: DXGI_MEMORY_SEGMENT_GROUP, pVideoMemoryInfo: *DXGI_QUERY_VIDEO_MEMORY_INFO) -> HRESULT #cpp_method #foreign;
    SetVideoMemoryReservation : (this: *IDXGIAdapter3, NodeIndex: u32, MemorySegmentGroup: DXGI_MEMORY_SEGMENT_GROUP, Reservation: u64) -> HRESULT #cpp_method #foreign;
    RegisterVideoMemoryBudgetChangeNotificationEvent : (this: *IDXGIAdapter3, hEvent: HANDLE, pdwCookie: *DWORD) -> HRESULT #cpp_method #foreign;
    UnregisterVideoMemoryBudgetChangeNotification : (this: *IDXGIAdapter3, dwCookie: DWORD) -> void #cpp_method #foreign;
}

IID_IDXGISwapChain3 :: GUID.{0x94d99bdb,0xf1f8,0x4ab0, u8.[0xb2,0x36,0x7d,0xa0,0x17,0x0e,0xda,0xb1] };
IID_IDXGIOutput4    :: GUID.{0xdc7dca35,0x2196,0x414d, u8.[0x9F,0x53,0x61,0x78,0x84,0x03,0x2a,0x60] };
IID_IDXGIFactory4   :: GUID.{0x1bc6ea02,0xef36,0x464f, u8.[0xbf,0x0c,0x21,0xca,0x39,0xe5,0x16,0x8a] };
IID_IDXGIAdapter3   :: GUID.{0x645967A4,0x1392,0x4310, u8.[0xA7,0x98,0x80,0x53,0xCE,0x3E,0x93,0xFD] };

using DXGI_OUTDUPL_FLAG :: enum u32 {
    DXGI_OUTDUPL_COMPOSITED_UI_CAPTURE_ONLY :: 1;
}

//### from dxgi1_5.h

IDXGIOutput5 :: struct {
    using vtable : *IDXGIOutput5_VTable;
    uuid :: "80A07424-AB52-42EB-833C-0C42FD282D98";
    iid  :: IID_IDXGIOutput5;
}

IDXGIOutput5_VTable :: struct {
    using output4 : IDXGIOutput4_VTable;
    DuplicateOutput1 : (this: *IDXGIOutput5, pDevice: *IUnknown, Flags: u32, SupportedFormatsCount: u32, pSupportedFormats: *DXGI_FORMAT, ppOutputDuplication: **IDXGIOutputDuplication) -> HRESULT #cpp_method #foreign;
}

using DXGI_HDR_METADATA_TYPE :: enum u32 {
    DXGI_HDR_METADATA_TYPE_NONE :: 0;
    DXGI_HDR_METADATA_TYPE_HDR10 :: 1;
    DXGI_HDR_METADATA_TYPE_HDR10PLUS :: 2;
}

DXGI_HDR_METADATA_HDR10 :: struct {
    RedPrimary: [2] u16;
    GreenPrimary: [2] u16;
    BluePrimary: [2] u16;
    WhitePoint: [2] u16;
    MaxMasteringLuminance: u32;
    MinMasteringLuminance: u32;
    MaxContentLightLevel: u16;
    MaxFrameAverageLightLevel: u16;
}

DXGI_HDR_METADATA_HDR10PLUS :: struct {
    Data: [72] u8;
}

IDXGISwapChain4 :: struct {
    using vtable : *IDXGISwapChain4_VTable;
    uuid :: "3D585D5A-BD4A-489E-B1F4-3DBCB6452FFB";
    iid  :: IID_IDXGISwapChain4;
}

IDXGISwapChain4_VTable :: struct {
    using swap_chain3 : IDXGISwapChain3_VTable;
    SetHDRMetaData : (this: *IDXGISwapChain4, Type: DXGI_HDR_METADATA_TYPE, Size: u32, pMetaData: *void) -> HRESULT #cpp_method #foreign;
}

using DXGI_OFFER_RESOURCE_FLAGS :: enum u32 {
    DXGI_OFFER_RESOURCE_FLAG_ALLOW_DECOMMIT :: 1;
}

using DXGI_RECLAIM_RESOURCE_RESULTS :: enum u32 {
    DXGI_RECLAIM_RESOURCE_RESULT_OK :: 0;
    DXGI_RECLAIM_RESOURCE_RESULT_DISCARDED :: 1;
    DXGI_RECLAIM_RESOURCE_RESULT_NOT_COMMITTED :: 2;
}


IDXGIDevice4 :: struct {
    using vtable : *IDXGIDevice4_VTable;
    uuid :: "95B4F95F-D8DA-4CA4-9EE6-3B76D5968A10";
    iid  :: IID_IDXGIDevice4;
}

IDXGIDevice4_VTable :: struct {
    using device3 : IDXGIDevice3_VTable;
    OfferResources1 : (this: *IDXGIDevice4, NumResources: u32, ppResources: **IDXGIResource, Priority: DXGI_OFFER_RESOURCE_PRIORITY, Flags: u32) -> HRESULT #cpp_method #foreign;
    ReclaimResources1 : (this: *IDXGIDevice4, NumResources: u32, ppResources: **IDXGIResource, pResults: *DXGI_RECLAIM_RESOURCE_RESULTS) -> HRESULT #cpp_method #foreign;
}

using DXGI_FEATURE :: enum u32 {
    DXGI_FEATURE_PRESENT_ALLOW_TEARING :: 0;
}

IDXGIFactory5 :: struct {
    using vtable : *IDXGIFactory5_VTable;
    uuid :: "7632e1f5-ee65-4dca-87fd-84cd75f8838d";
    iid  :: IID_IDXGIFactory5;
}

IDXGIFactory5_VTable :: struct {
    using factory4 : IDXGIFactory4_VTable;
    CheckFeatureSupport : (this: *IDXGIFactory5, Feature: DXGI_FEATURE, pFeatureSupportData: *void, FeatureSupportDataSize: u32) -> HRESULT #cpp_method #foreign;
}

IID_IDXGIOutput5    :: GUID.{0x80A07424,0xAB52,0x42EB, u8.[0x83,0x3C,0x0C,0x42,0xFD,0x28,0x2D,0x98] };
IID_IDXGISwapChain4 :: GUID.{0x3D585D5A,0xBD4A,0x489E, u8.[0xB1,0xF4,0x3D,0xBC,0xB6,0x45,0x2F,0xFB] };
IID_IDXGIDevice4    :: GUID.{0x95B4F95F,0xD8DA,0x4CA4, u8.[0x9E,0xE6,0x3B,0x76,0xD5,0x96,0x8A,0x10] };
IID_IDXGIFactory5   :: GUID.{0x7632e1f5,0xee65,0x4dca, u8.[0x87,0xfd,0x84,0xcd,0x75,0xf8,0x83,0x8d] };

DXGIDeclareAdapterRemovalSupport :: () -> HRESULT #foreign dxgi;

using DXGI_ADAPTER_FLAG3 :: enum u32 {
    DXGI_ADAPTER_FLAG3_NONE :: 0;
    DXGI_ADAPTER_FLAG3_REMOTE :: 1;
    DXGI_ADAPTER_FLAG3_SOFTWARE :: 2;
    DXGI_ADAPTER_FLAG3_ACG_COMPATIBLE :: 4;
    DXGI_ADAPTER_FLAG3_SUPPORT_MONITORED_FENCES :: 8;
    DXGI_ADAPTER_FLAG3_SUPPORT_NON_MONITORED_FENCES :: 16;
    DXGI_ADAPTER_FLAG3_KEYED_MUTEX_CONFORMANCE :: 32;
    //DXGI_ADAPTER_FLAG3_FORCE_DWORD :: -1;
}


DXGI_ADAPTER_DESC3 :: struct {
    Description: [128] u16;
    VendorId: u32;
    DeviceId: u32;
    SubSysId: u32;
    Revision: u32;
    DedicatedVideoMemory: SIZE_T;
    DedicatedSystemMemory: SIZE_T;
    SharedSystemMemory: SIZE_T;
    AdapterLuid: LUID;
    Flags: DXGI_ADAPTER_FLAG3;
    GraphicsPreemptionGranularity: DXGI_GRAPHICS_PREEMPTION_GRANULARITY;
    ComputePreemptionGranularity: DXGI_COMPUTE_PREEMPTION_GRANULARITY;
}

//### from dxgi1_6.h

IDXGIAdapter4 :: struct {
    using vtable : *IDXGIAdapter4_VTable;
    uuid :: "3c8d99d1-4fbf-4181-a82c-af66bf7bd24e";
    iid  :: IID_IDXGIAdapter4;
}

IDXGIAdapter4_VTable :: struct {
    using adapter3 : IDXGIAdapter3_VTable;
    GetDesc3 : (this: *IDXGIAdapter4, pDesc: *DXGI_ADAPTER_DESC3) -> HRESULT #cpp_method #foreign;
}

DXGI_OUTPUT_DESC1 :: struct {
    DeviceName: [32] u16;
    DesktopCoordinates: RECT;
    AttachedToDesktop: BOOL;
    Rotation: DXGI_MODE_ROTATION;
    Monitor: HMONITOR;
    BitsPerColor: u32;
    ColorSpace: DXGI_COLOR_SPACE_TYPE;
    RedPrimary: [2] float32;
    GreenPrimary: [2] float32;
    BluePrimary: [2] float32;
    WhitePoint: [2] float32;
    MinLuminance: float32;
    MaxLuminance: float32;
    MaxFullFrameLuminance: float32;
}

using DXGI_HARDWARE_COMPOSITION_SUPPORT_FLAGS :: enum u32 {
    DXGI_HARDWARE_COMPOSITION_SUPPORT_FLAG_FULLSCREEN :: 1;
    DXGI_HARDWARE_COMPOSITION_SUPPORT_FLAG_WINDOWED :: 2;
    DXGI_HARDWARE_COMPOSITION_SUPPORT_FLAG_CURSOR_STRETCHED :: 4;
}


IDXGIOutput6 :: struct {
    using vtable : *IDXGIOutput6_VTable;
    uuid :: "068346e8-aaec-4b84-add7-137f513f77a1";
    iid  :: IID_IDXGIOutput5;
}

IDXGIOutput6_VTable :: struct {
    using output5 : IDXGIOutput5_VTable;
    GetDesc1 : (this: *IDXGIOutput6, pDesc: *DXGI_OUTPUT_DESC1) -> HRESULT #cpp_method #foreign;
    CheckHardwareCompositionSupport : (this: *IDXGIOutput6, pFlags: *u32) -> HRESULT #cpp_method #foreign;
}

using DXGI_GPU_PREFERENCE :: enum u32 {
    DXGI_GPU_PREFERENCE_UNSPECIFIED :: 0;
    DXGI_GPU_PREFERENCE_MINIMUM_POWER :: 1;
    DXGI_GPU_PREFERENCE_HIGH_PERFORMANCE :: 2;
}


IDXGIFactory6 :: struct {
    using vtable : *IDXGIFactory6_VTable;
    uuid :: "c1b6694f-ff09-44a9-b03c-77900a0a1d17";
    iid  :: IID_IDXGIFactory6;
}

IDXGIFactory6_VTable :: struct {
    using factory5 : IDXGIFactory5_VTable;
    EnumAdapterByGpuPreference : (this: *IDXGIFactory6, Adapter: u32, GpuPreference: DXGI_GPU_PREFERENCE, riid: *IID, ppvAdapter: **void) -> HRESULT #cpp_method #foreign;
}

IDXGIFactory7 :: struct {
    using vtable : *IDXGIFactory7_VTable;
    uuid :: "a4966eed-76db-44da-84c1-ee9a7afb20a8";
    iid  :: IID_IDXGIFactory7;
}

IDXGIFactory7_VTable :: struct {
    using factory6 : IDXGIFactory6_VTable;
    RegisterAdaptersChangedEvent : (this: *IDXGIFactory7, hEvent: HANDLE, pdwCookie: *DWORD) -> HRESULT #cpp_method #foreign;
    UnregisterAdaptersChangedEvent : (this: *IDXGIFactory7, dwCookie: DWORD) -> HRESULT #cpp_method #foreign;
}

IID_IDXGIAdapter4   :: GUID.{0x3c8d99d1,0x4fbf,0x4181, u8.[0xa8,0x2c,0xaf,0x66,0xbf,0x7b,0xd2,0x4e] };
IID_IDXGIOutput6    :: GUID.{0x068346e8,0xaaec,0x4b84, u8.[0xad,0xd7,0x13,0x7f,0x51,0x3f,0x77,0xa1] };
IID_IDXGIFactory6   :: GUID.{0xc1b6694f,0xff09,0x44a9, u8.[0xb0,0x3c,0x77,0x90,0x0a,0x0a,0x1d,0x17] };
IID_IDXGIFactory7   :: GUID.{0xa4966eed,0x76db,0x44da, u8.[0x84,0xc1,0xee,0x9a,0x7a,0xfb,0x20,0xa8] };


//## dxgidebug.h
using DXGI_DEBUG_RLO_FLAGS :: enum u32 {
    DXGI_DEBUG_RLO_SUMMARY :: 1;
    DXGI_DEBUG_RLO_DETAIL :: 2;
    DXGI_DEBUG_RLO_IGNORE_INTERNAL :: 4;
    DXGI_DEBUG_RLO_ALL :: 7;
}

DXGI_DEBUG_ID :: GUID;

DXGI_DEBUG_ALL  :: GUID.{0xe48ae283, 0xda80, 0x490b, u8.[0x87, 0xe6, 0x43, 0xe9, 0xa9, 0xcf, 0xda, 0x8] };
DXGI_DEBUG_DX   :: GUID.{0x35cdd7fc, 0x13b2, 0x421d, u8.[0xa5, 0xd7, 0x7e, 0x44, 0x51, 0x28, 0x7d, 0x64] };
DXGI_DEBUG_DXGI :: GUID.{0x25cddaa4, 0xb1c6, 0x47e1, u8.[0xac, 0x3e, 0x98, 0x87, 0x5b, 0x5a, 0x2e, 0x2a] };
DXGI_DEBUG_APP  :: GUID.{0x6cd6e01, 0x4219, 0x4ebd,  u8.[0x87, 0x9, 0x27, 0xed, 0x23, 0x36, 0xc, 0x62] };

using DXGI_INFO_QUEUE_MESSAGE_CATEGORY :: enum u32 {
    DXGI_INFO_QUEUE_MESSAGE_CATEGORY_UNKNOWN :: 0;
    DXGI_INFO_QUEUE_MESSAGE_CATEGORY_MISCELLANEOUS :: 1;
    DXGI_INFO_QUEUE_MESSAGE_CATEGORY_INITIALIZATION :: 2;
    DXGI_INFO_QUEUE_MESSAGE_CATEGORY_CLEANUP :: 3;
    DXGI_INFO_QUEUE_MESSAGE_CATEGORY_COMPILATION :: 4;
    DXGI_INFO_QUEUE_MESSAGE_CATEGORY_STATE_CREATION :: 5;
    DXGI_INFO_QUEUE_MESSAGE_CATEGORY_STATE_SETTING :: 6;
    DXGI_INFO_QUEUE_MESSAGE_CATEGORY_STATE_GETTING :: 7;
    DXGI_INFO_QUEUE_MESSAGE_CATEGORY_RESOURCE_MANIPULATION :: 8;
    DXGI_INFO_QUEUE_MESSAGE_CATEGORY_EXECUTION :: 9;
    DXGI_INFO_QUEUE_MESSAGE_CATEGORY_SHADER :: 10;
}

using DXGI_INFO_QUEUE_MESSAGE_SEVERITY :: enum u32 {
    DXGI_INFO_QUEUE_MESSAGE_SEVERITY_CORRUPTION :: 0;
    DXGI_INFO_QUEUE_MESSAGE_SEVERITY_ERROR :: 1;
    DXGI_INFO_QUEUE_MESSAGE_SEVERITY_WARNING :: 2;
    DXGI_INFO_QUEUE_MESSAGE_SEVERITY_INFO :: 3;
    DXGI_INFO_QUEUE_MESSAGE_SEVERITY_MESSAGE :: 4;
}

DXGI_INFO_QUEUE_MESSAGE_ID :: s32;

DXGI_INFO_QUEUE_MESSAGE :: struct {
    Producer: DXGI_DEBUG_ID;
    Category: DXGI_INFO_QUEUE_MESSAGE_CATEGORY;
    Severity: DXGI_INFO_QUEUE_MESSAGE_SEVERITY;
    ID: DXGI_INFO_QUEUE_MESSAGE_ID;
    pDescription: *u8;
    DescriptionByteLength: SIZE_T;
}

DXGI_INFO_QUEUE_FILTER_DESC :: struct {
    NumCategories: u32;
    pCategoryList: *DXGI_INFO_QUEUE_MESSAGE_CATEGORY;
    NumSeverities: u32;
    pSeverityList: *DXGI_INFO_QUEUE_MESSAGE_SEVERITY;
    NumIDs: u32;
    pIDList: *DXGI_INFO_QUEUE_MESSAGE_ID;
}

DXGI_INFO_QUEUE_FILTER :: struct {
    AllowList: DXGI_INFO_QUEUE_FILTER_DESC;
    DenyList: DXGI_INFO_QUEUE_FILTER_DESC;
}

// DXGIGetDebugInterface :: (riid: *IID, ppDebug: **void) -> HRESULT #foreign dxgi;

IDXGIInfoQueue :: struct {
    using vtable : *IDXGIInfoQueue_VTable;
    uuid :: "D67441C7-672A-476f-9E82-CD55B44949CE";
    iid  :: IID_IDXGIInfoQueue;
}

IDXGIInfoQueue_VTable :: struct {
    using unknown : IUnknown_VTable;
    SetMessageCountLimit : (this: *IDXGIInfoQueue, Producer: DXGI_DEBUG_ID, MessageCountLimit: u64) -> HRESULT #cpp_method #foreign;
    ClearStoredMessages : (this: *IDXGIInfoQueue, Producer: DXGI_DEBUG_ID) -> void #cpp_method #foreign;
    GetMessage : (this: *IDXGIInfoQueue, Producer: DXGI_DEBUG_ID, MessageIndex: u64, pMessage: *DXGI_INFO_QUEUE_MESSAGE, pMessageByteLength: *SIZE_T) -> HRESULT #cpp_method #foreign;
    GetNumStoredMessagesAllowedByRetrievalFilters : (this: *IDXGIInfoQueue, Producer: DXGI_DEBUG_ID) -> u64 #cpp_method #foreign;
    GetNumStoredMessages : (this: *IDXGIInfoQueue, Producer: DXGI_DEBUG_ID) -> u64 #cpp_method #foreign;
    GetNumMessagesDiscardedByMessageCountLimit : (this: *IDXGIInfoQueue, Producer: DXGI_DEBUG_ID) -> u64 #cpp_method #foreign;
    GetMessageCountLimit : (this: *IDXGIInfoQueue, Producer: DXGI_DEBUG_ID) -> u64 #cpp_method #foreign;
    GetNumMessagesAllowedByStorageFilter : (this: *IDXGIInfoQueue, Producer: DXGI_DEBUG_ID) -> u64 #cpp_method #foreign;
    GetNumMessagesDeniedByStorageFilter : (this: *IDXGIInfoQueue, Producer: DXGI_DEBUG_ID) -> u64 #cpp_method #foreign;
    AddStorageFilterEntries : (this: *IDXGIInfoQueue, Producer: DXGI_DEBUG_ID, pFilter: *DXGI_INFO_QUEUE_FILTER) -> HRESULT #cpp_method #foreign;
    GetStorageFilter : (this: *IDXGIInfoQueue, Producer: DXGI_DEBUG_ID, pFilter: *DXGI_INFO_QUEUE_FILTER, pFilterByteLength: *SIZE_T) -> HRESULT #cpp_method #foreign;
    ClearStorageFilter : (this: *IDXGIInfoQueue, Producer: DXGI_DEBUG_ID) -> void #cpp_method #foreign;
    PushEmptyStorageFilter : (this: *IDXGIInfoQueue, Producer: DXGI_DEBUG_ID) -> HRESULT #cpp_method #foreign;
    PushDenyAllStorageFilter : (this: *IDXGIInfoQueue, Producer: DXGI_DEBUG_ID) -> HRESULT #cpp_method #foreign;
    PushCopyOfStorageFilter : (this: *IDXGIInfoQueue, Producer: DXGI_DEBUG_ID) -> HRESULT #cpp_method #foreign;
    PushStorageFilter : (this: *IDXGIInfoQueue, Producer: DXGI_DEBUG_ID, pFilter: *DXGI_INFO_QUEUE_FILTER) -> HRESULT #cpp_method #foreign;
    PopStorageFilter : (this: *IDXGIInfoQueue, Producer: DXGI_DEBUG_ID) -> void #cpp_method #foreign;
    GetStorageFilterStackSize : (this: *IDXGIInfoQueue, Producer: DXGI_DEBUG_ID) -> u32 #cpp_method #foreign;
    AddRetrievalFilterEntries : (this: *IDXGIInfoQueue, Producer: DXGI_DEBUG_ID, pFilter: *DXGI_INFO_QUEUE_FILTER) -> HRESULT #cpp_method #foreign;
    GetRetrievalFilter : (this: *IDXGIInfoQueue, Producer: DXGI_DEBUG_ID, pFilter: *DXGI_INFO_QUEUE_FILTER, pFilterByteLength: *SIZE_T) -> HRESULT #cpp_method #foreign;
    ClearRetrievalFilter : (this: *IDXGIInfoQueue, Producer: DXGI_DEBUG_ID) -> void #cpp_method #foreign;
    PushEmptyRetrievalFilter : (this: *IDXGIInfoQueue, Producer: DXGI_DEBUG_ID) -> HRESULT #cpp_method #foreign;
    PushDenyAllRetrievalFilter : (this: *IDXGIInfoQueue, Producer: DXGI_DEBUG_ID) -> HRESULT #cpp_method #foreign;
    PushCopyOfRetrievalFilter : (this: *IDXGIInfoQueue, Producer: DXGI_DEBUG_ID) -> HRESULT #cpp_method #foreign;
    PushRetrievalFilter : (this: *IDXGIInfoQueue, Producer: DXGI_DEBUG_ID, pFilter: *DXGI_INFO_QUEUE_FILTER) -> HRESULT #cpp_method #foreign;
    PopRetrievalFilter : (this: *IDXGIInfoQueue, Producer: DXGI_DEBUG_ID) -> void #cpp_method #foreign;
    GetRetrievalFilterStackSize : (this: *IDXGIInfoQueue, Producer: DXGI_DEBUG_ID) -> u32 #cpp_method #foreign;
    AddMessage : (this: *IDXGIInfoQueue, Producer: DXGI_DEBUG_ID, Category: DXGI_INFO_QUEUE_MESSAGE_CATEGORY, Severity: DXGI_INFO_QUEUE_MESSAGE_SEVERITY, ID: DXGI_INFO_QUEUE_MESSAGE_ID, pDescription: LPCSTR) -> HRESULT #cpp_method #foreign;
    AddApplicationMessage : (this: *IDXGIInfoQueue, Severity: DXGI_INFO_QUEUE_MESSAGE_SEVERITY, pDescription: LPCSTR) -> HRESULT #cpp_method #foreign;
    SetBreakOnCategory : (this: *IDXGIInfoQueue, Producer: DXGI_DEBUG_ID, Category: DXGI_INFO_QUEUE_MESSAGE_CATEGORY, bEnable: BOOL) -> HRESULT #cpp_method #foreign;
    SetBreakOnSeverity : (this: *IDXGIInfoQueue, Producer: DXGI_DEBUG_ID, Severity: DXGI_INFO_QUEUE_MESSAGE_SEVERITY, bEnable: BOOL) -> HRESULT #cpp_method #foreign;
    SetBreakOnID : (this: *IDXGIInfoQueue, Producer: DXGI_DEBUG_ID, ID: DXGI_INFO_QUEUE_MESSAGE_ID, bEnable: BOOL) -> HRESULT #cpp_method #foreign;
    GetBreakOnCategory : (this: *IDXGIInfoQueue, Producer: DXGI_DEBUG_ID, Category: DXGI_INFO_QUEUE_MESSAGE_CATEGORY) -> BOOL #cpp_method #foreign;
    GetBreakOnSeverity : (this: *IDXGIInfoQueue, Producer: DXGI_DEBUG_ID, Severity: DXGI_INFO_QUEUE_MESSAGE_SEVERITY) -> BOOL #cpp_method #foreign;
    GetBreakOnID : (this: *IDXGIInfoQueue, Producer: DXGI_DEBUG_ID, ID: DXGI_INFO_QUEUE_MESSAGE_ID) -> BOOL #cpp_method #foreign;
    SetMuteDebugOutput : (this: *IDXGIInfoQueue, Producer: DXGI_DEBUG_ID, bMute: BOOL) -> void #cpp_method #foreign;
    GetMuteDebugOutput : (this: *IDXGIInfoQueue, Producer: DXGI_DEBUG_ID) -> BOOL #cpp_method #foreign;
}

IDXGIDebug :: struct {
    using vtable : *IDXGIDebug_VTable;
    uuid :: "119E7452-DE9E-40fe-8806-88F90C12B441";
    iid  :: IID_IDXGIDebug;
}

IDXGIDebug_VTable :: struct {
    using unknown : IUnknown_VTable;
    ReportLiveObjects : (this: *IDXGIDebug, apiid: GUID, flags: DXGI_DEBUG_RLO_FLAGS) -> HRESULT #cpp_method #foreign;
}

IDXGIDebug1 :: struct {
    using vtable : *IDXGIDebug1_VTable;
    uuid :: "c5a05f0c-16f2-4adf-9f4d-a8c4d58ac550";
    iid  :: IID_IDXGIDebug1;
}

IDXGIDebug1_VTable :: struct {
    using debug : IDXGIDebug_VTable;
    EnableLeakTrackingForThread : (this: *IDXGIDebug1) -> void #cpp_method #foreign;
    DisableLeakTrackingForThread : (this: *IDXGIDebug1) -> void #cpp_method #foreign;
    IsLeakTrackingEnabledForThread : (this: *IDXGIDebug1) -> BOOL #cpp_method #foreign;
}

IID_IDXGIInfoQueue :: GUID.{0xD67441C7,0x672A,0x476f, u8.[0x9E,0x82,0xCD,0x55,0xB4,0x49,0x49,0xCE] };
IID_IDXGIDebug     :: GUID.{0x119E7452,0xDE9E,0x40fe, u8.[0x88,0x06,0x88,0xF9,0x0C,0x12,0xB4,0x41] };
IID_IDXGIDebug1    :: GUID.{0xc5a05f0c,0x16f2,0x4adf, u8.[0x9f,0x4d,0xa8,0xc4,0xd5,0x8a,0xc5,0x50] };

#scope_file
#import "Windows";
dxgi :: #foreign_system_library "DXGI";